/*
 *  $Id: tools.icc,v 1.4 2003/08/19 19:20:00 tuexen Exp $
 *
 * SocketAPI implementation for the sctplib.
 * Copyright (C) 1999-2003 by Thomas Dreibholz
 *
 * Realized in co-operation between
 * - Siemens AG
 * - University of Essen, Institute of Computer Networking Technology
 * - University of Applied Sciences, Muenster
 *
 * Acknowledgement
 * This work was partially funded by the Bundesministerium fuer Bildung und
 * Forschung (BMBF) of the Federal Republic of Germany (Foerderkennzeichen 01AK045).
 * The authors alone are responsible for the contents.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * There are two mailinglists available at http://www.sctp.de which should be
 * used for any discussion related to this implementation.
 *
 * Contact: discussion@sctp.de
 *          dreibh@exp-math.uni-essen.de
 *          tuexen@fh-muenster.de
 *
 * Purpose: Tools Implementation
 *
 */

#ifndef TOOLS_ICC
#define TOOLS_ICC


#include "tools.h"

#include <sys/time.h>
#include <errno.h>


// Use system's byteswap functions
#if (SYSTEM == OS_Linux)
#define USE_BYTESWAP
#endif



// ###### Calculate the current time in milliseconds from 01-Jan-1970 #######
inline card64 getMicroTime()
{
  struct timeval tv;
  gettimeofday(&tv,NULL);
  return(((card64)tv.tv_sec * (card64)1000000) + (card64)tv.tv_usec);
}


// ###### Debug output ######################################################
inline void debug(const char* string)
{
   cerr << string << endl;
   cerr.flush();
}



// ###### QuickSort algorithm ###############################################
template<class T> void quickSort(T*            array,
                                 const integer start,
                                 const integer end)
{
   const T v = array[(start + end) / 2];
   integer i = start;
   integer j = end;

   do {
      while(array[i] < v) i++;
      while(array[j] > v) j--;
      if(i <= j) {
         const T temp = array[i];
         array[i] = array[j];
         array[j] = temp;
         i++;
         j--;
      }
   } while(j >= i);

   if(start < j) {
      quickSort(array,start,j);
   }
   if(i < end) {
      quickSort(array,i,end);
   }
}


// ###### QuickSort algorithm ###############################################
template<class T> void quickSortPtr(T*            array,
                                    const integer start,
                                    const integer end,
                                    bool (*lt)(T,T),
                                    bool (*gt)(T,T))
{
   const T v = array[(start + end) / 2];
   integer i = start;
   integer j = end;

   do {
      while(lt(array[i],v)) i++;
      while(gt(array[j],v)) j--;
      if(i <= j) {
         const T temp = array[i];
         array[i] = array[j];
         array[j] = temp;
         i++;
         j--;
      }
   } while(j >= i);

   if(start < j) {
      quickSortPtr(array,start,j,lt,gt);
   }
   if(i < end) {
      quickSortPtr(array,i,end,lt,gt);
   }
}


// ###### QuickSort algorithm for groups ####################################
template<class T> void quickSortGroupPtr(T*            array,
                                         const integer start,
                                         const integer end,
                                         bool (*lt)(T,T),
                                         bool (*gt)(T,T),
                                         bool (*geq)(T,T))
{
   if((end - start) > 1) {
      integer s = start;
      integer i;
      for(i = start + 1;i <= end;i++) {
         if(!geq(array[s],array[i])) {
            quickSortPtr(array,s,i - 1,lt,gt);
            s = i;
         }
      }
      if(!geq(array[s],array[i])) {
         quickSortPtr(array,s,i - 1,lt,gt);
      }
   }
}


// ###### Remove duplicates #################################################
template<class T> cardinal removeDuplicates(T*             array,
                                            const cardinal length)
{
   cardinal counter;
   if(length <= 1) {
      counter = length;
   }
   else {
      counter = 0;
      for(cardinal i = 1;i < length;i++) {
         if(array[counter] != array[i]) {
            counter++;
            array[counter] = array[i];
         }
      }
      counter++;
   }
   return(counter);
}


#endif
